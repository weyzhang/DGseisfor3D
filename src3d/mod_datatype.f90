!*******************************************************************!
!*  This module declares datatypes and data structures of 3-d DG   *!
!*                                                                 *!
!*  Author: Ruichao Ye    Email: Ruichao.ye@gmail.com              *!
!*******************************************************************!

!--------------------------------------------------------------------
module datatype_mod
!--------------------------------------------------------------------

    implicit none

    public :: rkind            !float & integer precision
    public :: vector_array     !array with 3 components
    public :: tensor_array     !array with 6 components
    public :: wavefield        !wavefield variable
    public :: auxilary_array   !auxilary wavefield variable
    public :: matrices         !discreted matrices
    public :: tetmesh_geometry !tetrahedral elements geometry
    public :: tetmesh_Domain   !parallel subdomain information
    public :: tetmesh_material !tetrahedral elements materials
    public :: PML_geometry     !perfectly-matching layer geometry
    public :: point_source     !point source information
    public :: sources          !source as a group
    public :: receivers        !receivers' information
    public :: rupture          !rupture parameters and variables
    public :: surface          !triangular external surface
    public :: pointer_vec_int,pointer_vec_real

    integer,parameter :: rkind = 8
    real(kind=rkind),parameter :: PI=3.1415926535897932384626d0

!-------------------------------------------------------------------

    type pointer_vec_real
       real(kind=rkind),pointer :: p(:)
    end type pointer_vec_real

    type pointer_vec_int
       integer,pointer :: p(:)
    end type pointer_vec_int

    type pointer_mat_real
       real(kind=rkind),pointer :: p(:,:)
    end type pointer_mat_real

    type vector_array 
       real(kind = rkind),pointer :: array(:)
       logical :: initiated=.false.
       real(kind = rkind),pointer :: x(:),y(:),z(:)
       ! array(3*Ndim)
       !   x=>array(       1:  Ndim)
       !   y=>array(  Ndim+1:2*Ndim)
       !   z=>array(2*Ndim+1:3*Ndim)
    end type vector_array

    type tensor_array 
       real(kind = rkind),pointer :: array(:)
       logical :: initiated=.false.
       logical :: symmetric
       real(kind = rkind),pointer :: xx(:),yy(:),zz(:),&
                                     yz(:),xz(:),xy(:),&
                                     zy(:),zx(:),yx(:)
       ! array(6*Ndim) for symmetric tensor
       !   xx=>array(       1:  Ndim)
       !   yy=>array(  Ndim+1:2*Ndim)
       !   zz=>array(2*Ndim+1:3*Ndim)
       !   yz=>array(3*Ndim+1:4*Ndim)
       !   xz=>array(4*Ndim+1:5*Ndim)
       !   xy=>array(5*Ndim+1:6*Ndim)
       ! array(9*Ndim) for symmetric tensor
       !   xx=>array(       1:  Ndim)
       !   yy=>array(  Ndim+1:2*Ndim)
       !   zz=>array(2*Ndim+1:3*Ndim)
       !   yz=>array(3*Ndim+1:4*Ndim)
       !   xz=>array(4*Ndim+1:5*Ndim)
       !   xy=>array(5*Ndim+1:6*Ndim)
       !   zy=>array(6*Ndim+1:7*Ndim)
       !   zx=>array(7*Ndim+1:8*Ndim)
       !   yx=>array(8*Ndim+1:9*Ndim)
    end type tensor_array

    type wavefield
       real(kind = rkind),pointer :: array(:)
       logical :: initiated=.false.
       type(vector_array) :: V
       type(tensor_array) :: E,S
       ! array(9*Ndim / 12*Ndim) 
       !   V%array=>array( 1 : 3*Ndim )
       !   E|S%array=>array( 3*Ndim+1 : 9*Ndim / 12*Ndim )
       type(vector_array) :: U
    end type wavefield

    type auxilary_array
       real(kind = rkind),pointer :: array(:)
       logical :: initiated=.false.
       type(tensor_array) :: S,fE
       type(vector_array) :: V,fV
    end type auxilary_array

    type send_recv_info
       integer :: N_DD_Conn
       ! number of neighbouring domains
       integer,pointer :: DD_Conn(:)
       ! neighbouring domain list
       !   dim(N_DD_Conn)
       !   if DD_Conn(i)<0, no need to exchange
       integer,pointer :: N_Conn(:)
       ! number of elements for each neighbouring subdomain
       !   dim(N_DD_Conn)
       integer :: maxN_Conn
       ! maxval(N_Conn)
       integer,pointer :: Mask(:,:)
       ! list of elements for each neighbouring subdomain
       !   dim(maxN_Conn,N_DD_Conn)
       !   can be deallocated after MPI_COMMIT
    end type send_recv_info

    type send_recv_pack
       type(send_recv_info) :: host,gost
       integer,pointer :: SStype(:),RRtype(:) 
       ! send and reveive type
       !   generated by MPI_TYPE_COMMIT
       !   used in MPI_isend and MPI_irecv
       integer,pointer :: send_req(:),recv_req(:)
       integer,pointer :: sta(:,:)
    end type send_recv_pack

    type receivers
       integer :: Nrecv,Nt,Nrecord,Ncomp
       real(kind=rkind) :: recdt
       integer,pointer :: recv2ele(:)
       !maps from receiver to element
       integer,pointer :: globID(:)
       !global ID of receivers in subdomain
       real(kind=rkind),pointer :: rnodalw(:,:)
       !weight of nodes in sub-element
       real(kind=rkind),pointer :: rec_buffer(:,:,:) 
       !rec_buffer(Nt,Nrecv,Ncomp) stores acquisition
       logical,pointer :: switchoff(:)
    end type receivers

    type surface
       integer :: Nface
       ! number of boundary faces with surface source
       type(vector_array) :: coord
       ! coordinates of nodal points on surface 
       !   dim(3*Nfp*Nface)
       real(kind=rkind),pointer :: nx(:),ny(:),nz(:)
       ! normal direction of facets
       !   dim(Nface)
       type(vector_array) :: Sn
       ! boundary traction force on surface 
       !   dim(3*Nfp*Nface)
    end type surface

    type rupture_matrices
       real(kind=rkind),pointer :: &
           irm(:),irp(:),&
           ! dim (pNp), rho^-1
           Dm(:,:,:),Dp(:,:,:),&
           ! dim (pNp,pNp,3), (Dx,Dy,Dz)
           Dn(:,:,:),&
           ! dim (pNp,pNp,2), (Dmn,Dpn)
           Jm(:,:),Jp(:,:),&
           ! dim (pNp,Nfp), blocks of LIFT
           Lm(:,:),Lp(:,:),&
           ! dim (Nfp,pNp), generated by rupt%perm and vmapM
           Cm(:,:,:),Cp(:,:,:),&
           ! dim (pNp,9,9)
           irDDm(:,:),irDDp(:,:),&
           ! dim (pNp*3,pNp*9)
       !!!!!!!!!!!!!!!!!!! for debug !!!!!!!!!!!!!
           DDm(:,:),DDp(:,:),&
           ! dim (pNp*9,pNp*3)
           irJLmm(:,:),irJLmp(:,:),irJLpm(:,:),irJLpp(:,:),&
           ! dim (pNp*3,pNp*3)
           RJLmm(:,:),RJLmp(:,:),RJLpm(:,:),RJLpp(:,:),&
           ! dim (pNp*9,pNp*3)
           irDCm(:,:),irDCp(:,:),&
           ! dim (pNp*3,pNp*9)
           irJLRCmm(:,:),irJLRCmp(:,:),irJLRCpm(:,:),irJLRCpp(:,:),&
           ! dim (pNp*3,pNp*9)
           irJm(:,:),irJp(:,:),&
           ! dim (pNp*3,Nfp*3)
           RJLRCmm(:,:),RJLRCmp(:,:),RJLRCpm(:,:),RJLRCpp(:,:),&
           ! dim (pNp*9,pNp*9)
           RJm(:,:),RJp(:,:),&
           ! dim (pNp*9,Nfp*3)
           KLRCm(:,:),KLRCp(:,:),&
           ! dim (Nfp*3,pNp*9)
           BLRCm(:,:),BLRCp(:,:)
           ! dim (Nfp,pNp*9)
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       real(kind=rkind),pointer :: A11(:,:),A12(:,:),A21(:,:),A22(:,:)
       ! A11(6*Nfp+24*pNp,6*Nfp+24*pNp)
       ! A12(6*Nfp+24*pNp,7*Nfp       )
       ! A21(4*Nfp       ,6*Nfp+24*pNp)
       ! A22(4*Nfp       ,7*Nfp       )
       real(kind=rkind),pointer :: &
           AUmUm(:,:),AUmVm(:,:),AUpUp(:,:),AUpVp(:,:),&
           AEmUm(:,:),AEmUp(:,:),AEmEm(:,:),AEmEp(:,:),&
           AEmVm(:,:),AEmVp(:,:),AEmVt(:,:),&
           AEpUm(:,:),AEpUp(:,:),AEpEm(:,:),AEpEp(:,:),&
           AEpVm(:,:),AEpVp(:,:),AEpVt(:,:),&
           AVmUm(:,:),AVmUp(:,:),AVmEm(:,:),AVmEp(:,:),&
           AVmVm(:,:),AVmVp(:,:),AVmVt(:,:),&
           AVpUm(:,:),AVpUp(:,:),AVpEm(:,:),AVpEp(:,:),&
           AVpVm(:,:),AVpVp(:,:),AVpVt(:,:),&
           ATfUm(:,:),ATfUp(:,:),ATfEm(:,:),ATfEp(:,:),&
           ATfTf(:,:),&
           ATnUm(:,:),ATnUp(:,:),ATnEm(:,:),ATnEp(:,:),&
           ATnTn(:,:),&
           BVmEm(:,:),BVmEp(:,:),BVpEm(:,:),BVpEp(:,:)
       real(kind=rkind),pointer :: Ab1(:,:),Ab2(:,:)
       integer,pointer :: pA11(:),pAb1(:)
       type(pointer_mat_real) :: Abb(4,3)
       real(kind=rkind),pointer :: g0m(:,:),g0p(:,:)
    end type rupture_matrices

    type rupture
       integer :: globNface
       integer :: Nface
       integer :: Nhface
       integer,pointer :: globID(:)
       integer,pointer :: perm(:,:,:)
       ! permute nodal points on face to element
       !   dim(Nfp,2,Nbface), value [1~pNp]
       !   perm(:,1,:) is the positive side
       !   perm(:,2,:) is the negative side
       integer,pointer :: T2E(:,:)
       ! triangle to element map
       !   dim(4,Nface)
       !   T2E(:,1:2) contains element ID value [1~Nele]
       !   T2E(:,3:4) contains element face ID [1~4]
       type(vector_array) :: coord
       ! coordinate of nodal points on rupture 
       !   dim(3*Nfp*Nface)
       real(kind = rkind),pointer :: Jac(:,:),invJac(:,:)
       ! Jacobian and inverse Jacobian
       ! dim(9,Nele)
       real(kind = rkind),pointer :: detJ(:),EscalM(:,:),EscalP(:,:)
       integer,pointer :: MmapM(:),MmapP(:),PmapM(:),PmapP(:)
       integer,pointer :: nmap(:)
       real(kind = rkind),pointer :: avg(:),weigh(:)
   ! rupture parameters 
       real(kind = rkind),pointer :: a(:),b(:),L(:),V0(:),f0(:)
       ! nonlinear aging law parameters 
       !   dim (Nfp*Nface)
       type(vector_array) :: tau0
       ! shear prestress traction
       !   dim(3*Nfp*Nface)
       real(kind = rkind),pointer :: sigma0(:)
       ! pre-compression normal stress 
       !   dim(Nfp*Nface)
       type(vector_array) :: Vt0
       ! aseismic slip velocity
       !   dim(3*Nfp*Nface)
   ! time varient
       real(kind = rkind),pointer :: sigma(:)
       ! conpressive normal stress
       !   dim(Nfp*Nface)
       type(vector_array) :: tauf
       ! friction force ( = Cauchy stress )
       !   dim(Nfp*Nface)
       type(vector_array) :: Vt
       ! shear slip velocity
       !   dim(Nfp*Nface)
       real(kind = rkind),pointer :: dVt(:)
       ! shear slip rate 
       !   dim(Nfp*Nface)
       real(kind = rkind),pointer :: psi(:)
       ! state variable 
       !   dim(Nfp*Nface)
       type(vector_array) :: Um,Up,Vm,Vp
       !   dim(pNp*Nface*3)
       ! particle displacement on -/+ side
       type(tensor_array) :: Em,Ep
       !   dim(pNp*Nface*9)
       ! particle displacement on -/+ side
    ! extra output measurement
       real(kind = rkind),pointer :: f(:)
       ! friction coefficient 
       !   dim(Nfp*Nface)
       type(vector_array) :: tau
       ! traction force 
       !   dim(3*Nfp*Nface)
       real(kind = rkind),pointer :: crack_t(:)
       ! rupture cracking time 
       !   dim(Nfp*Nface)
    ! Nonlinear matrices
       type(rupture_matrices),pointer :: M(:)
    ! domain exchange
       type(send_recv_pack) :: SRtype
    ! receivers
       type(receivers) :: recvs
    endtype rupture

    type PML_geometry
       logical :: pml
       type(vector_array) :: damp
       ! damping coefficients based on nodal points
       ! dim(pNp*Nele)
    ! domain exchange
       type(send_recv_pack) :: SRtype
    ! rotational PML
       integer :: Nele
       ! Number of elements in PMLayers
       integer,pointer :: ipml(:)
       ! global index of PML elements 
       ! dim(Npml)
       real(kind = rkind),pointer :: Jac(:,:,:)
       ! coordinate transform for rotational pml
       ! dim(9,Npml)
    end type PML_geometry

    type tetmesh_geometry
    ! Geometry related
       integer :: Nele
       ! number of elements including ghosts
       integer :: Nhele
       ! number of elements excluding ghosts
       integer :: Ninele
       ! number of interior elements excluding ghosts and hosts
       integer,pointer :: globID(:)
       ! Global ID and local ID of the element
       ! dim(Nele)
       type(vector_array) :: coord
       ! coordinates of nodal points
       real(kind=rkind),pointer :: nx(:,:),ny(:,:),nz(:,:)
       ! normal direction of facets
       ! dim(4,Nele)
       ! Outer normal vector for each face
       real(kind = rkind),pointer :: Jac(:,:),invJac(:,:)
       ! Jacobian and inverse Jacobian
       ! initiated by Build_geometry, dim(9,Nele)
       real(kind = rkind),pointer :: detJ(:)
       ! Jacobian determinant
       ! initiated by Build_geometry, dim(Nele)
       real(kind = rkind),pointer :: Fscale(:,:)
       ! sJac/detJ
       ! initiated by Build_geometry, dim(4,Nele)
       integer,pointer :: vmapM(:),vmapP(:)
       ! maps to nodal points on facets
       ! initiated by Build_geometry, dim(Nele*Nfp)
       integer,pointer :: fbctype(:,:,:)
       ! interface types for each triangle facet
       ! dimension fbctype(2,4,Nele):
       ! 0: natural boundary condition
       !   0: solid-solid boundary
       !   1: inside solid, outside fluid (for solid eles)
       !   2: inside fluid, outside solid (for fluid eles)
       !   3: fluid-fluid boundary
       ! 1: external boundary condition
       !   1: free surface boundary
       !   2: absorbing boundary
       ! 2: rupture boundary condition (with rupture parameters)
       !   i: indicates |i|th rupture parameter class,
       !        sign(i)=-dot(mesh%n,surf%n) correspondingly
       ! 3: external boundary source
       !   i: indicates ith facet
       real(kind=rkind) :: xmax,xmin,ymax,ymin,zmax,zmin
       ! physical domain range
       type(surface) :: surf
       ! External boundary info and temporary storage
       type(rupture) :: rupt
       ! Ruptures info and temporary storage
       type(PML_geometry) :: PMLinfo
       ! PML geometry structure
       logical,pointer :: EXflag(:),IMflag(:)
       ! indicator for explicit/implicit time stepping
    end type tetmesh_geometry

    type tetmesh_Domain
    ! Domain decomposition
       integer :: id
       ! domain id
       integer :: pid
       ! processor id
       integer,pointer :: local_tet(:,:)
       ! local tetrahedral -> vertices map
       ! dim(4,local_Nele), deallocated after build_geometry
       integer,pointer :: local_neigh(:,:)
       ! local tetrahedral -> tetrahedral map
       ! dim(4,local_Nele), deallocated after build_geometry
       type(send_recv_pack) :: SRtype,SRtype1
    end type tetmesh_Domain

    type matrices
       real(kind=rkind), pointer :: V3D(:,:),iV3D(:,:),&
           M3D(:,:),iM3D(:,:),Dr(:,:),Ds(:,:),Dt(:,:),&
           Drw(:,:),Dsw(:,:),Dtw(:,:)
       ! dim(pNp,pNp)
       real(kind=rkind), pointer :: V2D(:,:),iV2D(:,:),&
           M2D(:,:),iM2D(:,:),Dr2D(:,:),Ds2D(:,:)
       ! dim(Nfp,Nfp)
       real(kind=rkind), pointer :: Lift(:,:),Lift2D(:,:)
       ! dim(pNp,4*Nfp)
       integer,pointer :: Fmask(:,:)
       ! dim(pNp*3,pNp*3,Nhele)
       real(kind=rkind),pointer :: G0(:,:,:)
    end type matrices

    type tetmesh_material
    ! media parameters
       real(kind = rkind),pointer :: Cp(:),Cs(:)
       ! for visualization only
       real(kind = rkind),pointer :: rho(:)
       ! for acoustic,isoelastic
       real(kind = rkind),pointer :: C(:,:)
       ! for acoustic:               c = [lambda]
       ! for isotropic elastic:      c = [lambda,2*mu]
       ! for orthorhombic-elastic:   c = [c11,c22,c33,
       !                                  c44,c55,c66,
       !                                  c23,c13,c12]
       ! for general aniso-elastic:  c = [c11,c22,c33,
       !                                  c44,c55,c66,
       !                                  c23,c13,c12,
       !                                  c14,c15,c16,
       !                                  c24,c25,c26,
       !                                  c34,c35,c36,
       !                                  c45,c46,c56]
       integer,pointer :: k_media(:)
       ! 0: acoustic
       ! 1: isotropic elastic
       ! 2: orthorhombic-elastic
       ! 3: general aniso-elastic
       integer :: job
       ! [ With smart domain partitioning, that is,  ]
       ! [ putting different types of materials into ]
       ! [ different subdomains, we can have local   ]
       ! [ job type for computing strain -> stress.  ]
       ! [ This is important for gloabl seismology.  ]
       logical :: prestressed
       ! the material is prestressed
       type(tensor_array) :: T0
       ! prestress tensor
       type(vector_array) :: g0
       ! gravity acceleration
    end type tetmesh_material

    type point_source
       integer :: globID
       ! global ID of this source
       real(kind = rkind) :: stime,ftime
       ! start time and final time
       real(kind = rkind) :: x,y,z
       ! location of source
       real(kind = rkind) :: q(9)
       ! source components:[E11,E22,E33,E23,E13,E12,v1,v2,v3]
       ! [may be replaced by[S11,S22,S33,S23,S13,S12,v1,v2,v3]]
       real(kind = rkind) :: lag
       ! lag time and amplification of source
       integer :: st_type
       ! source time function type: 
       ! 0.Ricker 
       ! 1.sequence
       ! 2.initial pulse
       ! 3.rupture perturbation

       !******** (Ricker or rupture) ************************!
       real(kind = rkind) :: freq,amp
       !source-time fun parameter

       !******** (read-in sequence) *************************!
       integer :: Nseq
       ! number of sampling point
       integer :: NsignComp
       ! number of component for signal source
       !       1: pressure, applied to S11,S22,S33
       !       3: velocity, applied to v1, v2, v3
       !       6: stress, applied to Sij
       !       9: applied to all component
       real(kind = rkind),pointer :: signal(:,:),ddsignal(:,:)
       ! sequence and its second time derivative
       ! dim(Nseq,NsignComp)
       real(kind = rkind) :: recdt
       ! sampling interval
       real(kind = rkind) :: rect
       ! sampling length

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!  For applying source into mesh  !!!!!!!!!
    ! Nodal wise apply, Gaussian source
       !relation to mesh geometry
       integer :: Nnod
       !number of nodal points covered by this source
       integer, pointer :: src2nod(:)
       !src2nod(Nnod) pick nodal points covered by this source
       real(kind = rkind),pointer :: sweight(:)
       !sweight(Nnod) weight for nodal points covered by source
    end type point_source

    type sources
    ! Body source
       integer :: N_bodysrc
       ! number of body point sources
       type(point_source),pointer :: bodysrc(:)
       ! point body source list
       ! dim(N_bodysrc)
    ! Surface source
       integer :: N_surfsrc
       ! number of surface point sources
       type(point_source),pointer :: surfsrc(:)
       ! point surface source list
       ! dim(N_surfsrc)
       ! jointly work with type(surface)
    ! Rupture source
       integer :: N_ruptsrc
       ! number of surface point sources
       type(point_source),pointer :: ruptsrc(:)
       ! point surface source list
       ! dim(N_surfsrc)
       ! jointly work with type(surface)
    ! External surface with Neumann BC
       integer :: analyBC=0
       ! jointly work with type(surface)
       ! 1: plane wave
       ! 2: Rayleigh wave
       ! 3: Scholte wave
       ! 4: Stoneley wave
    ! direct wave travel time estimate
       real(kind=rkind),pointer :: t_direct(:)
       ! initiated by init_source, dim(Nele)
    end type sources

!--------------------------------------------------------------------
    contains
!--------------------------------------------------------------------

subroutine ini_tensor(Ndim,E,symm)
    integer,intent(in) :: Ndim
    type(tensor_array) :: E
    logical,intent(in) :: symm
    if(Ndim.le.0 .or. E%initiated)return
    E%symmetric=symm
    if(symm)then
        allocate(E%array(Ndim*6))
        E%xx=>E%array(       1:  Ndim)
        E%yy=>E%array(  Ndim+1:2*Ndim)
        E%zz=>E%array(2*Ndim+1:3*Ndim)
        E%yz=>E%array(3*Ndim+1:4*Ndim)
        E%xz=>E%array(4*Ndim+1:5*Ndim)
        E%xy=>E%array(5*Ndim+1:6*Ndim)
        E%zy=>E%yz
        E%zx=>E%xz
        E%yx=>E%xy
    else
        allocate(E%array(Ndim*9))
        E%xx=>E%array(       1:  Ndim)
        E%yy=>E%array(  Ndim+1:2*Ndim)
        E%zz=>E%array(2*Ndim+1:3*Ndim)
        E%yz=>E%array(3*Ndim+1:4*Ndim)
        E%xz=>E%array(4*Ndim+1:5*Ndim)
        E%xy=>E%array(5*Ndim+1:6*Ndim)
        E%zy=>E%array(6*Ndim+1:7*Ndim)
        E%zx=>E%array(7*Ndim+1:8*Ndim)
        E%yx=>E%array(8*Ndim+1:9*Ndim)
    endif
    E%initiated=.true.
end subroutine ini_tensor

subroutine reset_tensor(E)
    type(tensor_array) :: E
    if(.not. E%initiated)return
    E%array=0d0
end subroutine reset_tensor

subroutine nul_tensor(E)
    type(tensor_array) :: E
    if(.not. E%initiated)return
    E%xx=>null()
    E%yy=>null()
    E%zz=>null()
    E%yz=>null()
    E%xz=>null()
    E%xy=>null()
    E%zy=>null()
    E%zx=>null()
    E%yx=>null()
    E%array=>null()
    E%initiated=.false.
end subroutine nul_tensor

subroutine del_tensor(E)
    type(tensor_array) :: E
    if(.not. E%initiated)return
    deallocate(E%array)
    call nul_tensor(E)
end subroutine del_tensor

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine ini_vector(Ndim,V)
    integer,intent(in) :: Ndim
    type(vector_array) :: V
    if(Ndim.le.0 .or. V%initiated)return
    allocate(V%array(Ndim*3))
    V%x=>V%array(       1:  Ndim)
    V%y=>V%array(  Ndim+1:2*Ndim)
    V%z=>V%array(2*Ndim+1:3*Ndim)
    V%initiated=.true.
end subroutine ini_vector

subroutine reset_vector(V)
    type(vector_array) :: V
    if(.not. V%initiated)return
    V%array=0d0
end subroutine reset_vector

subroutine nul_vector(V)
    type(vector_array) :: V
    if(.not. V%initiated)return
    V%x=>null()
    V%y=>null()
    V%z=>null()
    V%array=>null()
    V%initiated=.false.
end subroutine nul_vector

subroutine del_vector(V)
    type(vector_array) :: V
    if(.not. V%initiated)return
    deallocate(V%array)
    call nul_vector(V)
end subroutine del_vector

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine ini_wavefield(Ndim,W,symm)
    integer,intent(in) :: Ndim
    logical,intent(in) :: symm
    type(wavefield) :: W
    if(Ndim.le.0 .or. W%initiated)return
    if(symm)then
        allocate(W%array(Ndim*9))
    else
        allocate(W%array(Ndim*12))
    endif
    W%V%x    =>W%array(       1:  Ndim)
    W%V%y    =>W%array(  Ndim+1:2*Ndim)
    W%V%z    =>W%array(2*Ndim+1:3*Ndim)
    W%V%array=>W%array(       1:3*Ndim)
    W%E%xx   =>W%array(3*Ndim+1:4*Ndim)
    W%E%yy   =>W%array(4*Ndim+1:5*Ndim)
    W%E%zz   =>W%array(5*Ndim+1:6*Ndim)
    W%E%yz   =>W%array(6*Ndim+1:7*Ndim)
    W%E%xz   =>W%array(7*Ndim+1:8*Ndim)
    W%E%xy   =>W%array(8*Ndim+1:9*Ndim)
    if(symm)then
        W%E%zy=>W%E%yz
        W%E%zx=>W%E%xz
        W%E%yx=>W%E%xy
        W%E%array=>W%array(3*Ndim+1:9*Ndim)
    else
        W%E%zy=>W%array( 9*Ndim+1:10*Ndim)
        W%E%zx=>W%array(10*Ndim+1:11*Ndim)
        W%E%yx=>W%array(11*Ndim+1:12*Ndim)
        W%E%array=>W%array(3*Ndim+1:12*Ndim)
    endif
    W%initiated=.true.
    W%V%initiated=.true.
    W%E%initiated=.true.
    W%E%symmetric=symm
    W%S%initiated=.true.
    W%S%symmetric=symm
    W%S%array=>W%E%array
    W%S%xx=>W%E%xx;W%S%xy=>W%E%xy;W%S%xz=>W%E%xz
    W%S%yx=>W%E%yx;W%S%yy=>W%E%yy;W%S%yz=>W%E%yz
    W%S%zx=>W%E%zx;W%S%zy=>W%E%zy;W%S%zz=>W%E%zz
    call ini_vector(Ndim,W%U)
end subroutine ini_wavefield

subroutine reset_wavefield(W)
    type(wavefield) :: W
    if(.not. W%initiated)return
    W%array=0d0
    W%U%array=0d0
end subroutine reset_wavefield

subroutine del_wavefield(W)
    type(wavefield) :: W
    if(.not. W%initiated)return
    call nul_vector(W%V)
    call nul_tensor(W%E)
    call nul_tensor(W%S)
    deallocate(W%array)
    W%initiated=.false.
    call del_vector(W%U)
end subroutine del_wavefield

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine ini_auxilary_array(W,pNp,Nfp,Nele,symm)
    type(auxilary_array) :: W
    integer,intent(in) :: pNp,Nfp,Nele
    logical,intent(in) :: symm
    integer :: Ndim
    if(symm)then
        Ndim=max(36*Nfp*Nele,9*pNp*Nele)
    else
        Ndim=max(48*Nfp*Nele,12*pNp*Nele)
    endif
    if(Ndim.le.0 .or. W%initiated)return
    allocate(W%array(Ndim))
    W%initiated=.true.
    W%S%symmetric=symm
    W%S%initiated=.true.
    W%V%initiated=.true.
    Ndim=pNp*Nele
    W%V%x    =>W%array(       1:  Ndim)
    W%V%y    =>W%array(  Ndim+1:2*Ndim)
    W%V%z    =>W%array(2*Ndim+1:3*Ndim)
    W%V%array=>W%array(1:3*Ndim)
    W%S%xx   =>W%array(3*Ndim+1:4*Ndim)
    W%S%yy   =>W%array(4*Ndim+1:5*Ndim)
    W%S%zz   =>W%array(5*Ndim+1:6*Ndim)
    W%S%yz   =>W%array(6*Ndim+1:7*Ndim)
    W%S%xz   =>W%array(7*Ndim+1:8*Ndim)
    W%S%xy   =>W%array(8*Ndim+1:9*Ndim)
    if(symm)then
        W%S%zy=>W%S%yz
        W%S%zx=>W%S%xz
        W%S%yx=>W%S%xy
        W%S%array=>W%array(3*Ndim+1:9*Ndim)
    else
        W%S%zy=>W%array( 9*Ndim+1:10*Ndim)
        W%S%zx=>W%array(10*Ndim+1:11*Ndim)
        W%S%yx=>W%array(11*Ndim+1:12*Ndim)
        W%S%array=>W%array(3*Ndim+1:12*Ndim)
    endif
    W%fE%symmetric=symm
    W%fE%initiated=.true.
    W%fV%initiated=.true.
    Ndim=4*Nfp*Nele
    W%fV%x    =>W%array(       1:  Ndim)
    W%fV%y    =>W%array(  Ndim+1:2*Ndim)
    W%fV%z    =>W%array(2*Ndim+1:3*Ndim)
    W%fV%array=>W%array(       1:3*Ndim)
    W%fE%xx   =>W%array(3*Ndim+1:4*Ndim)
    W%fE%yy   =>W%array(4*Ndim+1:5*Ndim)
    W%fE%zz   =>W%array(5*Ndim+1:6*Ndim)
    W%fE%yz   =>W%array(6*Ndim+1:7*Ndim)
    W%fE%xz   =>W%array(7*Ndim+1:8*Ndim)
    W%fE%xy   =>W%array(8*Ndim+1:9*Ndim)
    if(symm)then
        W%fE%zy=>W%fE%yz
        W%fE%zx=>W%fE%xz
        W%fE%yx=>W%fE%xy
        W%fE%array=>W%array(3*Ndim+1:9*Ndim)
    else
        W%fE%zy=>W%array( 9*Ndim+1:10*Ndim)
        W%fE%zx=>W%array(10*Ndim+1:11*Ndim)
        W%fE%yx=>W%array(11*Ndim+1:12*Ndim)
        W%fE%array=>W%array(3*Ndim+1:12*Ndim)
    endif
end subroutine ini_auxilary_array

subroutine reset_auxilary_array(W)
    type(auxilary_array) :: W
    if(.not. W%initiated)return
    W%array=0d0
end subroutine reset_auxilary_array

subroutine del_auxilary_array(W)
    type(auxilary_array) :: W
    if(.not. W%initiated)return
    call nul_vector(W%V)
    call nul_vector(W%fV)
    call nul_tensor(W%S)
    call nul_tensor(W%fE)
    deallocate(W%array)
    W%initiated=.false.
end subroutine del_auxilary_array

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine vector_SCAL(Ndim,A,V)
    integer,intent(in) :: Ndim
    real(kind=rkind),intent(in) :: A
    type(vector_array) :: V
    call DSCAL(Ndim*3,A,V%array,1)
end subroutine vector_SCAL

subroutine tensor_SCAL(Ndim,A,E)
    integer,intent(in) :: Ndim
    real(kind=rkind),intent(in) :: A
    type(tensor_array) :: E
    if(E%symmetric)then
        call DSCAL(Ndim*6,A,E%array,1)
    else
        call DSCAL(Ndim*9,A,E%array,1)
    endif
end subroutine tensor_SCAL

subroutine wavefield_SCAL(Ndim,A,W)
    integer,intent(in) :: Ndim
    real(kind=rkind),intent(in) :: A
    type(wavefield) :: W
    if(W%E%symmetric)then
        call DSCAL(Ndim*9,A,W%array,1)
    else
        call DSCAL(Ndim*12,A,W%array,1)
    endif
end subroutine wavefield_SCAL

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine vector_COPY(Ndim,V,W)
    integer,intent(in) :: Ndim
    type(vector_array) :: V,W
    call DCOPY(Ndim*3,V%array,1,W%array,1)
end subroutine vector_COPY

subroutine tensor_COPY(Ndim,E,H)
    integer,intent(in) :: Ndim
    type(tensor_array) :: E,H
    if(E%symmetric)then
        call DCOPY(Ndim*6,E%array,1,H%array,1)
    else
        call DCOPY(Ndim*9,E%array,1,H%array,1)
    endif
end subroutine tensor_COPY

subroutine wavefield_COPY(Ndim,W,U)
    integer,intent(in) :: Ndim
    type(wavefield) :: W,U
    if(W%E%symmetric)then
        call DCOPY(Ndim*9,W%array,1,U%array,1)
    else
        call DCOPY(Ndim*12,W%array,1,U%array,1)
    endif
end subroutine wavefield_COPY

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine vector_AXPY(Ndim,A,V,W)
    integer,intent(in) :: Ndim
    real(kind=rkind),intent(in) :: A
    type(vector_array) :: V,W
    call DAXPY(Ndim*3,A,V%array,1,W%array,1)
end subroutine vector_AXPY

subroutine tensor_AXPY(Ndim,A,E,H)
    integer,intent(in) :: Ndim
    real(kind=rkind),intent(in) :: A
    type(tensor_array) :: E,H
    if(E%symmetric.or.H%symmetric)then
        call DAXPY(Ndim*6,A,E%array,1,H%array,1)
    else
        call DAXPY(Ndim*9,A,E%array,1,H%array,1)
    endif
end subroutine tensor_AXPY

subroutine wavefield_AXPY(Ndim,A,W,U)
    integer,intent(in) :: Ndim
    real(kind=rkind),intent(in) :: A
    type(wavefield) :: W,U
    if(W%E%symmetric)then
        call DAXPY(Ndim*9,A,W%array,1,U%array,1)
    else
        call DAXPY(Ndim*12,A,W%array,1,U%array,1)
    endif
end subroutine wavefield_AXPY

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

function wavefield_INFNORM(Ndim,W)
    integer,intent(in) :: Ndim
    real(kind=rkind):: wavefield_INFNORM,Wmax,tmp
    type(wavefield) :: W
    integer :: N
    Wmax=dabs(W%array(1))
    do N=2,9*Ndim
        tmp=dabs(W%array(N))
        if(tmp.gt.Wmax)Wmax=tmp
    enddo
    wavefield_INFNORM=Wmax
end function wavefield_INFNORM

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine BLK_axpy(Np,Nele,a,x,y)
    ! y=a*x+y
    ! x,y: dim(Np*Nele)
    ! a  : dim(Nele)
    integer,intent(in) :: Np,Nele
    real(kind=rkind) :: a(Nele),x(Np*Nele),y(Np*Nele)
    integer :: i,j,k
    k=0
    do i=1,Nele
        do j=1,Np
            k=k+1
            y(k)=y(k)+a(i)*x(k)
        enddo
    enddo
end subroutine BLK_axpy

subroutine DiagMM(PROD,M,N,ALPHA,A,B,C,LDB,LDC)
    ! DiagMM  performs diagonal matrix-matrix production
    ! PROD specifies Left/Right product with diagonal matrix
    ! PROD = 'L' or 'l'  C := alpha*A*B + C,
    ! PROD = 'R' or 'r'  C := alpha*B*A + C,
    ! A is M X M diagonal matrix, 
    ! B and C are M X N or N X M matrix depending on PROD
    real(kind=rkind),intent(in) :: ALPHA
    character,intent(in) :: PROD
    integer,intent(in) :: LDB,LDC,M,N
    real(kind=rkind) :: A(M),B(LDB,*),C(LDC,*)
    logical :: LX
    integer :: i,j
    LX = PROD.eq.'L' .or. PROD.eq.'l'
    if(LX)then
        if(ALPHA.eq.1d0)then
            do i=1,N
                do j=1,M
                    C(j,i)=C(j,i)+A(j)*B(j,i)
                enddo
            enddo
        else
            do i=1,N
                do j=1,M
                    C(j,i)=C(j,i)+A(j)*B(j,i)*ALPHA
                enddo
            enddo
        endif
    else
        if(ALPHA.eq.1d0)then
            do i=1,M
                do j=1,N
                    C(j,i)=C(j,i)+A(i)*B(j,i)
                enddo
            enddo
        else
            do i=1,M
                do j=1,N
                    C(j,i)=C(j,i)+A(i)*B(j,i)*ALPHA
                enddo
            enddo
        endif
    endif
    return
end subroutine DiagMM

subroutine DiagMMw(PROD,M,N,A,B,LDB)
    ! DiagMM  performs diagonal matrix-matrix production
    ! PROD specifies Left/Right product with diagonal matrix
    ! PROD = 'L' or 'l'  B := A*B,
    ! PROD = 'R' or 'r'  B := B*A,
    ! A is M X M diagonal matrix, 
    ! B is M X N or N X M matrix depending on PROD
    character,intent(in) :: PROD
    integer,intent(in) :: LDB,M,N
    real(kind=rkind) :: A(M),B(LDB,*)
    logical :: LX
    integer :: i,j
    LX = PROD.eq.'L' .or. PROD.eq.'l'
    if(LX)then
        do i=1,N
            do j=1,M
                B(j,i)=A(j)*B(j,i)
            enddo
        enddo
    else
        do i=1,M
            do j=1,N
                B(j,i)=A(i)*B(j,i)
            enddo
        enddo
    endif
end subroutine DiagMMw

subroutine Array_scale(N,a,X,Y)
    ! Y(N)=a*X(N)*Y(N)
    integer,intent(in) :: N
    real(kind=rkind),intent(in) :: X(N),a
    real(kind=rkind) :: Y(N)
    integer :: I,M,MP1!,IX,IY
    if(N.le.0)return
    M = mod(N,4)
    if(a.eq.1d0)then
        if(M.ne.0)then
            do I = 1,M
                Y(I) = X(I)*Y(I)
            enddo
        endif
        if(N.lt.4)return
        MP1 = M + 1
        do I = MP1,N,4
            Y(I  ) = X(I  )*Y(I  )
            Y(I+1) = X(I+1)*Y(I+1)
            Y(I+2) = X(I+2)*Y(I+2)
            Y(I+3) = X(I+3)*Y(I+3)
        enddo
    else
        if(M.ne.0)then
            do I = 1,M
                Y(I) = a*X(I)*Y(I)
            enddo
        endif
        if(N.lt.4)return
        MP1 = M + 1
        do I = MP1,N,4
            Y(I  ) = a*X(I  )*Y(I  )
            Y(I+1) = a*X(I+1)*Y(I+1)
            Y(I+2) = a*X(I+2)*Y(I+2)
            Y(I+3) = a*X(I+3)*Y(I+3)
        enddo
    endif
end subroutine Array_scale

subroutine Array_axypz(N,a,X,Y,Z)
    ! Z(N)=Z(N)+a*X(N)*Y(N)
    integer,intent(in) :: N
    real(kind=rkind),intent(in) :: X(N),Y(N),a
    real(kind=rkind) :: Z(N)
    integer :: I,M,MP1
    if(N.le.0)return
    if(a.eq.0d0)return
    M = mod(N,4)
    if(a.eq.1d0)then
        if(M.ne.0)then
            do I = 1,M
                Z(I) = Z(I) + X(I)*Y(I)
            enddo
        endif
        if(N.lt.4)return
        MP1 = M + 1
        do I = MP1,N,4
            Z(I  ) = Z(I  ) + X(I  )*Y(I  )
            Z(I+1) = Z(I+1) + X(I+1)*Y(I+1)
            Z(I+2) = Z(I+2) + X(I+2)*Y(I+2)
            Z(I+3) = Z(I+3) + X(I+3)*Y(I+3)
        enddo
    else
        if(M.ne.0)then
            do I = 1,M
                Z(I) = Z(I) + a*X(I  )*Y(I  )
            enddo
        endif
        if(N.lt.4)return
        MP1 = M + 1
        do I = MP1,N,4
            Z(I  ) = Z(I  ) + a*X(I  )*Y(I  )
            Z(I+1) = Z(I+1) + a*X(I+1)*Y(I+1)
            Z(I+2) = Z(I+2) + a*X(I+2)*Y(I+2)
            Z(I+3) = Z(I+3) + a*X(I+3)*Y(I+3)
        enddo
    endif

end subroutine Array_axypz

!--------------------------------------------------------------------

subroutine Array_permute(Na,Nb,N,a,b,I)
    integer,intent(in) :: Na,Nb,N
    integer,intent(in) :: I(Nb)
    real(kind=rkind),intent(in)  :: a(Na,N)
    real(kind=rkind),intent(out) :: b(Nb,N)
    integer :: j,k
    do k=1,N
        do j=1,Nb
            b(j,k)=a(I(j),k)
        enddo
    enddo
end subroutine Array_permute

end module datatype_mod
